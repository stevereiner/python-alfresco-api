# generated by datamodel-codegen:
#   filename:  alfresco-search.openapi3.yaml
#   timestamp: 2025-06-19T18:37:03+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel


class ContentInfo(BaseModel):
    encoding: Optional[str] = None
    mimeType: str
    mimeTypeGroup: Optional[str] = None
    mimeTypeName: str
    sizeInBytes: int


class Error1(BaseModel):
    briefSummary: Optional[str] = None
    descriptionURL: Optional[str] = None
    errorKey: Optional[str] = None
    logId: Optional[str] = None
    stackTrace: Optional[str] = None
    statusCode: Optional[int] = None


class Error(BaseModel):
    error: Error1


class BucketInfo(BaseModel):
    end: Optional[str] = Field(None, description="The end of range")
    endInclusive: Optional[bool] = Field(
        None, description='Includes values less than or equal to "end"'
    )
    start: Optional[str] = Field(None, description="The start of range")
    startInclusive: Optional[bool] = Field(
        None, description='Includes values greater or equal to "start"'
    )


class GenericMetric(BaseModel):
    type: Optional[str] = Field(None, description="The type of metric, e.g. count")
    value: Optional[Dict[str, Any]] = Field(
        None, description='The metric value, e.g. {"count": 34}\n'
    )


class Pagination(BaseModel):
    count: int = Field(..., description="The number of objects in the entries array.\n")
    hasMoreItems: bool = Field(
        ...,
        description="A boolean value which is **true** if there are more entities in the collection\nbeyond those in this response. A true value means a request with a larger value\nfor the **skipCount** or the **maxItems** parameter will return more entities.\n",
    )
    maxItems: int = Field(
        ...,
        description="The value of the **maxItems** parameter used to generate this list,\nor if there was no **maxItems** parameter the default value is 100\n",
    )
    skipCount: int = Field(
        ...,
        description="An integer describing how many entities exist in the collection before\nthose included in this list.\n",
    )
    totalItems: Optional[int] = Field(
        None,
        description="An integer describing the total number of entities in the collection.\nThe API might not be able to determine this value,\nin which case this property will not be present.\n",
    )


class PathElement(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None


class PathInfo(BaseModel):
    elements: Optional[List[PathElement]] = None
    isComplete: Optional[bool] = None
    name: Optional[str] = None


class DefaultFTSFieldOperator(Enum):
    AND = "AND"
    OR = "OR"


class DefaultFTSOperator(Enum):
    AND = "AND"
    OR = "OR"


class RequestDefaults(BaseModel):
    defaultFTSFieldOperator: Optional[DefaultFTSFieldOperator] = Field(
        "AND",
        description="The default way to combine query parts in field query groups when AND or OR is not explicitly stated - includes ! - +\nFIELD:(one two three)\n",
    )
    defaultFTSOperator: Optional[DefaultFTSOperator] = Field(
        "AND",
        description="The default way to combine query parts when AND or OR is not explicitly stated - includes ! - +\none two three\n(one two three)\n",
    )
    defaultFieldName: Optional[str] = "TEXT"
    namespace: Optional[str] = Field(
        "cm", description="The default name space to use if one is not provided"
    )
    textAttributes: Optional[List[str]] = Field(
        None,
        description="A list of query fields/properties used to expand TEXT: queries.\nThe default is cm:content.\nYou could include all content properties using d:content or list all individual content properties or types.\nAs more terms are included the query size, complexity, memory impact and query time will increase.\n",
    )


class Method(Enum):
    ENUM = "ENUM"
    FC = "FC"


class Sort(Enum):
    COUNT = "COUNT"
    INDEX = "INDEX"


class RequestFacetField(BaseModel):
    excludeFilters: Optional[List[str]] = Field(
        None,
        description="Filter Queries with tags listed here will not be included in facet counts.\nThis is used for multi-select facetting.\n",
    )
    facetEnumCacheMinDf: Optional[int] = None
    field: Optional[str] = Field(None, description="The facet field")
    label: Optional[str] = Field(
        None, description="A label to include in place of the facet field"
    )
    limit: Optional[int] = None
    method: Optional[Method] = None
    mincount: Optional[int] = Field(
        1,
        description="The minimum count required for a facet field to be included in the response.",
    )
    missing: Optional[bool] = Field(
        False,
        description="When true, count results that match the query but which have no facet value for the field (in addition to the Term-based constraints).",
    )
    offset: Optional[int] = None
    prefix: Optional[str] = Field(
        None,
        description="Restricts the possible constraints to only indexed values with a specified prefix.",
    )
    sort: Optional[Sort] = None


class RequestFacetFields(BaseModel):
    facets: Optional[List[RequestFacetField]] = Field(
        None,
        description="Define specifc fields on which to facet (adds SOLR facet.field and f.<field>.facet.* options)\n",
    )


class RequestFacetQuery(BaseModel):
    label: Optional[str] = Field(
        None, description="A label to include in place of the facet query"
    )
    query: Optional[str] = Field(None, description="A facet query")


class RequestFacetQueries(RootModel[List[RequestFacetQuery]]):
    root: List[RequestFacetQuery] = Field(..., description="Facet queries to include")


class RequestFacetSet(BaseModel):
    end: Optional[str] = Field(None, description="The end of the range")
    endInclusive: Optional[bool] = Field(
        True,
        description='When true, the set will include values less than or equal to "end"',
    )
    label: Optional[str] = Field(None, description="A label to use to identify the set")
    start: Optional[str] = Field(None, description="The start of the range")
    startInclusive: Optional[bool] = Field(
        True,
        description='When true, the set will include values greater or equal to "start"',
    )


class RequestFields(RootModel[List[str]]):
    root: List[str] = Field(
        ...,
        description="A list of field names.\nYou can use this parameter to restrict the fields returned within a response if, for example, you want to save on overall bandwidth.\nThe list applies to a returned individual entity or entries within a collection.\nIf the **include** parameter is used aswell then the fields specified in the **include** parameter are returned in addition to those specified in the **fields** parameter.",
    )


class RequestFilterQuery(BaseModel):
    query: Optional[str] = Field(
        None,
        description="The filter query expression.\nFor multi-select facets selected facets must be order together\n",
    )
    tags: Optional[List[str]] = Field(
        None,
        description="Tags used exclude the filters from facet evaluation for multi-select facet support",
    )


class RequestFilterQueries(RootModel[List[RequestFilterQuery]]):
    root: List[RequestFilterQuery] = Field(
        ...,
        description="Filter Queries. Constraints that apply to the results set but do not affect the score of each entry.",
    )


class FieldModel(BaseModel):
    field: Optional[str] = Field(
        None, description="The name of the field to highlight."
    )
    fragmentSize: Optional[int] = None
    mergeContiguous: Optional[bool] = None
    postfix: Optional[str] = None
    prefix: Optional[str] = None
    snippetCount: Optional[int] = None


class RequestHighlight(BaseModel):
    fields: Optional[List[FieldModel]] = Field(
        None,
        description="The fields to highlight and field specific configuration properties for each field",
    )
    fragmentSize: Optional[int] = Field(
        None, description="The character length of each snippet."
    )
    maxAnalyzedChars: Optional[int] = Field(
        None,
        description="The number of characters to be considered for highlighting. Matches after this count will not be shown.",
    )
    mergeContiguous: Optional[bool] = Field(
        None,
        description="If fragments over lap they can be  merged into one larger fragment",
    )
    postfix: Optional[str] = Field(
        None,
        description="The string used to mark the end of a highlight in a fragment.",
    )
    prefix: Optional[str] = Field(
        None,
        description="The string used to mark the start of a highlight in a fragment.",
    )
    snippetCount: Optional[int] = Field(
        None,
        description="The maximum number of distinct highlight snippets to return for each highlight field.",
    )
    usePhraseHighlighter: Optional[bool] = Field(
        None, description="Should phrases be identified."
    )


class RequestIncludeEnum(Enum):
    allowableOperations = "allowableOperations"
    aspectNames = "aspectNames"
    isLink = "isLink"
    isLocked = "isLocked"
    path = "path"
    properties = "properties"


class RequestInclude(RootModel[List[RequestIncludeEnum]]):
    root: List[RequestIncludeEnum] = Field(
        ...,
        description="Returns additional information about the node. The following optional fields can be requested:\n * properties\n * aspectNames\n * path\n * isLink\n * allowableOperations\n * association\n",
    )


class RequestLimits(BaseModel):
    permissionEvaluationCount: Optional[int] = Field(
        2000, description="Maximum count of post query permission evaluations"
    )
    permissionEvaluationTime: Optional[int] = Field(
        20000, description="Maximum time for post query permission evaluation"
    )


class RequestLocalization(BaseModel):
    locales: Optional[List[str]] = Field(
        None,
        description="A list of Locales definied by IETF BCP 47.  The ordering is significant.  The first locale (leftmost) is used for sort and query localization, whereas the remaining locales are used for query only.",
    )
    timezone: Optional[str] = Field(
        None, description="A valid timezone id supported by @see java.time.ZoneId"
    )


class RequestPagination(BaseModel):
    maxItems: Optional[int] = Field(
        100,
        description="The maximum number of items to return in the query results",
        ge=1,
    )
    skipCount: Optional[int] = Field(
        0,
        description="The number of items to skip from the start of the query set",
        ge=0,
    )


class RequestPivot(BaseModel):
    key: Optional[str] = Field(
        None,
        description="A key corresponding to a matching field facet label or stats.",
    )
    pivots: Optional[List[RequestPivot]] = None


class Language(Enum):
    afts = "afts"
    lucene = "lucene"
    cmis = "cmis"


class RequestQuery(BaseModel):
    language: Optional[Language] = Field(
        "afts", description="The query language in which the query is written."
    )
    query: str = Field(
        ...,
        description="The query which may have been generated in some way from the userQuery",
    )
    userQuery: Optional[str] = Field(
        None, description="The exact search request typed in by the user"
    )


class RequestRange(BaseModel):
    end: Optional[str] = Field(None, description="The end of the range")
    excludeFilters: Optional[List[str]] = Field(
        None, description="Filter queries to exclude when calculating statistics"
    )
    field: Optional[str] = Field(
        None, description="The name of the field to perform range"
    )
    gap: Optional[str] = Field(None, description="Bucket size")
    hardend: Optional[bool] = Field(
        None,
        description="If true means that the last bucket will end at “end” even if it is less than “gap” wide.",
    )
    include: Optional[List[str]] = Field(
        None, description="lower, upper, edge, outer, all"
    )
    label: Optional[str] = Field(
        None, description="A label to include as a pivot reference"
    )
    other: Optional[List[str]] = Field(
        None, description="before, after, between, non, all"
    )
    start: Optional[str] = Field(None, description="The start of the range")


class Locations(Enum):
    nodes = "nodes"
    versions = "versions"
    deleted_nodes = "deleted-nodes"


class RequestScope(BaseModel):
    locations: Optional[Locations] = Field(
        None, description="The locations to include in the query\n"
    )


class Type(Enum):
    FIELD = "FIELD"
    DOCUMENT = "DOCUMENT"
    SCORE = "SCORE"


class RequestSortDefinitionItem(BaseModel):
    ascending: Optional[bool] = Field(
        False,
        description="The sort order. (The ordering of nulls is determined by the SOLR configuration)",
    )
    field: Optional[str] = Field(None, description="The name of the field")
    type: Optional[Type] = Field(
        "FIELD",
        description="How to order - using a field, when position of the document in the index, score/relevence.",
    )


class RequestSortDefinition(RootModel[List[RequestSortDefinitionItem]]):
    root: List[RequestSortDefinitionItem] = Field(
        ...,
        description="How to sort the rows? An array of sort specifications. The array order defines the ordering precedence.",
    )


class RequestSpellcheck(BaseModel):
    query: Optional[str] = None


class RequestStats(BaseModel):
    cardinality: Optional[bool] = Field(
        False,
        description="A statistical approximation of the number of distinct values",
    )
    cardinalityAccuracy: Optional[float] = Field(
        0.3,
        description="Number between 0.0 and 1.0 indicating how aggressively the algorithm should try to be accurate. Used with boolean cardinality flag.",
    )
    countDistinct: Optional[bool] = Field(
        False,
        description="The number of distinct values  (This can be very expensive to calculate)",
    )
    countValues: Optional[bool] = Field(
        True, description="The number which have a value for this field"
    )
    distinctValues: Optional[bool] = Field(
        False,
        description="The set of all distinct values for the field (This can be very expensive to calculate)",
    )
    excludeFilters: Optional[List[str]] = Field(
        None, description="A list of filters to exclude"
    )
    field: Optional[str] = Field(None, description="The stats field")
    label: Optional[str] = Field(
        None, description="A label to include for reference the stats field"
    )
    max: Optional[bool] = Field(True, description="The maximum value of the field")
    mean: Optional[bool] = Field(True, description="The average")
    min: Optional[bool] = Field(True, description="The minimum value of the field")
    missing: Optional[bool] = Field(
        True, description="The number which do not have a value for this field"
    )
    percentiles: Optional[List[float]] = Field(
        None, description='A list of percentile values, e.g. "1,99,99.9"'
    )
    stddev: Optional[bool] = Field(True, description="Standard deviation")
    sum: Optional[bool] = Field(True, description="The sum of all values of the field")
    sumOfSquares: Optional[bool] = Field(True, description="Sum of all values squared")


class RequestTemplate(BaseModel):
    name: Optional[str] = Field(None, description="The template name")
    template: Optional[str] = Field(None, description="The template")


class RequestTemplates(RootModel[List[RequestTemplate]]):
    root: List[RequestTemplate] = Field(
        ...,
        description='Templates usewd for query expansion.\nA template called "WOOF" defined as "%(cm:name cm:title)" allows\nWOOF:example\nto generate\ncm:name:example cm:name:example\n',
    )


class ResponseConsistency(BaseModel):
    lastTxId: Optional[int] = Field(
        None, description="The id of the last indexed transaction"
    )


class Bucket(BaseModel):
    count: Optional[int] = Field(None, description="The count for the bucket")
    display: Optional[Dict[str, Any]] = Field(
        None, description="An optional field for additional display information"
    )
    filterQuery: Optional[str] = Field(
        None, description="The filter query you can use to apply this facet"
    )
    label: Optional[str] = Field(None, description="The bucket label")


class ResultBuckets(BaseModel):
    buckets: Optional[List[Bucket]] = Field(
        None, description="An array of buckets and values"
    )
    label: Optional[str] = Field(
        None,
        description="The field name or its explicit label, if provided on the request",
    )


class FacetQuery(BaseModel):
    count: Optional[int] = None
    filterQuery: Optional[str] = Field(
        None, description="The filter query you can use to apply this facet"
    )
    label: Optional[str] = None


class Type1(Enum):
    searchInsteadFor = "searchInsteadFor"
    didYouMean = "didYouMean"


class SpellcheckItem(BaseModel):
    suggestion: Optional[List[str]] = Field(
        None, description="A suggested alternative query"
    )
    type: Optional[Type1] = None


class HighlightItem(BaseModel):
    field: Optional[str] = Field(
        None,
        description="The field where a match occured (one of the fields defined on the request)",
    )
    snippets: Optional[List[str]] = Field(
        None,
        description="Any number of snippets for the specified field highlighting the matching text",
    )


class SearchEntry(BaseModel):
    highlight: Optional[List[HighlightItem]] = Field(
        None,
        description="Highlight fragments if requested and available. A match can happen in any of the requested field.\n",
    )
    score: Optional[float] = Field(None, description="The score for this row")


class UserInfo(BaseModel):
    displayName: str
    id: str


class GenericBucket(BaseModel):
    bucketInfo: Optional[BucketInfo] = Field(
        None, description="Additional information of nested facet"
    )
    display: Optional[Dict[str, Any]] = Field(
        None, description="An optional field for additional display information"
    )
    facets: Optional[List[Dict[str, Any]]] = Field(
        None, description="Additional list of nested facets"
    )
    filterQuery: Optional[str] = Field(
        None, description="The filter query you can use to apply this facet"
    )
    label: Optional[str] = Field(None, description="The bucket label")
    metrics: Optional[List[GenericMetric]] = Field(
        None, description="An array of buckets and values"
    )


class GenericFacetResponse(BaseModel):
    buckets: Optional[List[GenericBucket]] = Field(
        None, description="An array of buckets and values"
    )
    label: Optional[str] = Field(
        None,
        description="The field name or its explicit label, if provided on the request",
    )
    type: Optional[str] = Field(
        None, description="The facet type, eg. interval, range, pivot, stats"
    )


class Node(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    allowableOperations: Optional[List[str]] = None
    aspectNames: Optional[List[str]] = None
    content: Optional[ContentInfo] = None
    createdAt: datetime
    createdByUser: UserInfo
    id: str
    isFile: bool
    isFolder: bool
    isLink: Optional[bool] = None
    isLocked: Optional[bool] = False
    modifiedAt: datetime
    modifiedByUser: UserInfo
    name: str = Field(
        ...,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    nodeType: str
    parentId: Optional[str] = None
    path: Optional[PathInfo] = None
    properties: Optional[Dict[str, Any]] = None


class Interval(BaseModel):
    field: Optional[str] = Field(None, description="The field to facet on")
    label: Optional[str] = Field(
        None, description="A label to use to identify the field facet"
    )
    sets: Optional[List[RequestFacetSet]] = Field(
        None, description="Sets the intervals for all fields."
    )


class RequestFacetIntervals(BaseModel):
    intervals: Optional[List[Interval]] = Field(
        None, description="Specifies the fields to facet by interval."
    )
    sets: Optional[List[RequestFacetSet]] = Field(
        None, description="Sets the intervals for all fields."
    )


class ResultNode(Node):
    archivedAt: Optional[datetime] = None
    archivedByUser: Optional[UserInfo] = None
    search: Optional[SearchEntry] = None
    versionComment: Optional[str] = None
    versionLabel: Optional[str] = None


class ResultSetRowEntry(BaseModel):
    entry: ResultNode


class SearchRequest(BaseModel):
    defaults: Optional[RequestDefaults] = None
    facetFields: Optional[RequestFacetFields] = None
    facetIntervals: Optional[RequestFacetIntervals] = None
    facetQueries: Optional[RequestFacetQueries] = None
    fields: Optional[RequestFields] = None
    filterQueries: Optional[RequestFilterQueries] = None
    highlight: Optional[RequestHighlight] = None
    include: Optional[RequestInclude] = None
    includeRequest: Optional[bool] = Field(
        False, description="When true, include the original request in the response"
    )
    limits: Optional[RequestLimits] = None
    localization: Optional[RequestLocalization] = None
    paging: Optional[RequestPagination] = None
    pivots: Optional[List[RequestPivot]] = None
    query: RequestQuery
    ranges: Optional[List[RequestRange]] = None
    scope: Optional[RequestScope] = None
    sort: Optional[RequestSortDefinition] = None
    spellcheck: Optional[RequestSpellcheck] = None
    stats: Optional[List[RequestStats]] = None
    templates: Optional[RequestTemplates] = None


class ResultSetContext(BaseModel):
    consistency: Optional[ResponseConsistency] = None
    facetQueries: Optional[List[FacetQuery]] = Field(
        None, description="The counts from facet queries"
    )
    facets: Optional[List[GenericFacetResponse]] = Field(
        None, description="The faceted response"
    )
    facetsFields: Optional[List[ResultBuckets]] = Field(
        None, description="The counts from field facets"
    )
    request: Optional[SearchRequest] = None
    spellcheck: Optional[List[SpellcheckItem]] = Field(
        None,
        description='Suggested corrections\n\nIf zero results were found for the original query then a single entry of type "searchInsteadFor" will be returned.\nIf alternatives were found that return more results than the original query they are returned as "didYouMean" options.\nThe highest quality suggestion is first.\n',
    )


class ListModel(BaseModel):
    context: Optional[ResultSetContext] = None
    entries: Optional[List[ResultSetRowEntry]] = None
    pagination: Optional[Pagination] = None


class ResultSetPaging(BaseModel):
    list: Optional[ListModel] = None


RequestPivot.model_rebuild()
