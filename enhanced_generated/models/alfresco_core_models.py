# generated by datamodel-codegen:
#   filename:  alfresco-core.openapi3.yaml
#   timestamp: 2025-06-19T18:36:52+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field


class ActionBodyExec(BaseModel):
    actionDefinitionId: str
    params: Optional[Dict[str, Any]] = None
    targetId: Optional[str] = Field(
        None,
        description="The entity upon which to execute the action, typically a node ID or similar.",
    )


class ActionExecResult(BaseModel):
    id: str = Field(
        ..., description="The unique identifier of the action pending execution"
    )


class ActionExecResultEntry(BaseModel):
    entry: ActionExecResult


class ActionParameterDefinition(BaseModel):
    displayLabel: Optional[str] = None
    mandatory: Optional[bool] = None
    multiValued: Optional[bool] = None
    name: Optional[str] = None
    type: Optional[str] = None


class Activity(BaseModel):
    activitySummary: Optional[Dict[str, str]] = Field(
        None, description="An object summarizing the activity"
    )
    activityType: str = Field(..., description="The type of the activity posted")
    feedPersonId: str = Field(
        ..., description="The feed on which this activity was posted"
    )
    id: int = Field(..., description="The unique id of the activity")
    postPersonId: str = Field(
        ..., description="The id of the person who performed the activity"
    )
    postedAt: Optional[datetime] = Field(
        None, description="The date time at which the activity was performed"
    )
    siteId: Optional[str] = Field(
        None,
        description="The unique id of the site on which the activity was performed",
    )


class ActivityEntry(BaseModel):
    entry: Activity


class Association(BaseModel):
    assocType: str
    targetId: str


class AssociationBody(BaseModel):
    assocType: str
    targetId: str


class AssociationEntry(BaseModel):
    entry: Association


class AssociationInfo(BaseModel):
    assocType: str


class AuditApp(BaseModel):
    id: str
    isEnabled: Optional[bool] = True
    maxEntryId: Optional[int] = None
    minEntryId: Optional[int] = None
    name: Optional[str] = None


class AuditAppEntry(BaseModel):
    entry: Optional[AuditApp] = None


class AuditBodyUpdate(BaseModel):
    isEnabled: Optional[bool] = None


class Capabilities(BaseModel):
    isAdmin: Optional[bool] = None
    isGuest: Optional[bool] = None
    isMutable: Optional[bool] = None


class ChildAssociation(BaseModel):
    assocType: str
    childId: str


class ChildAssociationBody(BaseModel):
    assocType: str
    childId: str


class ChildAssociationEntry(BaseModel):
    entry: ChildAssociation


class ChildAssociationInfo(BaseModel):
    assocType: str
    isPrimary: bool


class ClientBody(BaseModel):
    client: str = Field(..., description="the client name")


class CommentBody(BaseModel):
    content: str


class Company(BaseModel):
    address1: Optional[str] = None
    address2: Optional[str] = None
    address3: Optional[str] = None
    email: Optional[str] = None
    fax: Optional[str] = None
    organization: Optional[str] = None
    postcode: Optional[str] = None
    telephone: Optional[str] = None


class Constraint(BaseModel):
    description: Optional[str] = Field(
        None, description="the human-readable constraint description"
    )
    id: str
    parameters: Optional[Dict[str, Dict[str, Any]]] = None
    title: Optional[str] = Field(
        None, description="the human-readable constraint title"
    )
    type: Optional[str] = Field(None, description="the type of the constraint")


class ContentInfo(BaseModel):
    encoding: Optional[str] = None
    mimeType: str
    mimeTypeName: Optional[str] = None
    sizeInBytes: Optional[int] = None


class DeletedNodeBodyRestore(BaseModel):
    assocType: Optional[str] = None
    targetParentId: Optional[str] = None


class DirectAccessUrlBodyCreate(BaseModel):
    expiresAt: Optional[datetime] = None
    validFor: Optional[int] = Field(
        None,
        description="The length of time in seconds that the url is valid for.\n",
        ge=1,
    )


class Status(Enum):
    PENDING = "PENDING"
    CANCELLED = "CANCELLED"
    IN_PROGRESS = "IN_PROGRESS"
    DONE = "DONE"
    MAX_CONTENT_SIZE_EXCEEDED = "MAX_CONTENT_SIZE_EXCEEDED"


class Download(BaseModel):
    bytesAdded: Optional[int] = Field(
        0, description="number of bytes added so far in the zip"
    )
    filesAdded: Optional[int] = Field(
        0, description="number of files added so far in the zip"
    )
    id: Optional[str] = Field(None, description="the id of the download node")
    status: Optional[Status] = Field(
        "PENDING", description="the current status of the download node creation"
    )
    totalBytes: Optional[int] = Field(
        0, description="the total number of bytes to be added in the zip"
    )
    totalFiles: Optional[int] = Field(
        0, description="the total number of files to be added in the zip"
    )


class DownloadBodyCreate(BaseModel):
    nodeIds: List[str]


class DownloadEntry(BaseModel):
    entry: Download


class Error1(BaseModel):
    briefSummary: Optional[str] = None
    descriptionURL: Optional[str] = None
    errorKey: Optional[str] = None
    logId: Optional[str] = None
    stackTrace: Optional[str] = None
    statusCode: Optional[int] = None


class Error(BaseModel):
    error: Error1


class Favorite(BaseModel):
    createdAt: Optional[datetime] = Field(
        None, description="The time the object was made a favorite."
    )
    properties: Optional[Dict[str, Any]] = Field(
        None,
        description="A subset of the target favorite properties, system properties and properties already available in the target are excluded.",
    )
    target: Dict[str, Any]
    targetGuid: str = Field(
        ..., description="The guid of the object that is a favorite."
    )


class FavoriteBodyCreate(BaseModel):
    target: Dict[str, Any]


class FavoriteEntry(BaseModel):
    entry: Favorite


class FavoriteSite(BaseModel):
    id: str


class FavoriteSiteBodyCreate(BaseModel):
    id: str


class FavoriteSiteEntry(BaseModel):
    entry: FavoriteSite


class Group(BaseModel):
    displayName: str
    id: str
    isRoot: bool
    parentIds: Optional[List[str]] = None
    zones: Optional[List[str]] = None


class GroupBodyCreate(BaseModel):
    displayName: str
    id: str
    parentIds: Optional[List[str]] = None


class GroupBodyUpdate(BaseModel):
    displayName: str


class GroupEntry(BaseModel):
    entry: Group


class MemberType(Enum):
    GROUP = "GROUP"
    PERSON = "PERSON"


class GroupMember(BaseModel):
    displayName: str
    id: str
    memberType: MemberType


class GroupMemberEntry(BaseModel):
    entry: GroupMember


class GroupMembershipBodyCreate(BaseModel):
    id: str
    memberType: MemberType


class NetworkQuota(BaseModel):
    id: str
    limit: int
    usage: int


class NodeBodyCopy(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    name: Optional[str] = Field(
        None,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    targetParentId: str


class Association1(BaseModel):
    assocType: Optional[str] = None


class Lifetime(Enum):
    PERSISTENT = "PERSISTENT"
    EPHEMERAL = "EPHEMERAL"


class Type(Enum):
    ALLOW_OWNER_CHANGES = "ALLOW_OWNER_CHANGES"
    FULL = "FULL"


class NodeBodyLock(BaseModel):
    lifetime: Optional[Lifetime] = "PERSISTENT"
    timeToExpire: Optional[int] = Field(None, ge=0)
    type: Optional[Type] = "ALLOW_OWNER_CHANGES"


class NodeBodyMove(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    name: Optional[str] = Field(
        None,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    targetParentId: str


class Pagination(BaseModel):
    count: Optional[int] = Field(
        None, description="The number of objects in the entries array.\n"
    )
    hasMoreItems: Optional[bool] = Field(
        None,
        description="A boolean value which is **true** if there are more entities in the collection\nbeyond those in this response. A true value means a request with a larger value\nfor the **skipCount** or the **maxItems** parameter will return more entities.\n",
    )
    maxItems: Optional[int] = Field(
        None,
        description="The value of the **maxItems** parameter used to generate this list.\nIf there was no **maxItems** parameter then the default value is 100.\n",
    )
    skipCount: Optional[int] = Field(
        None,
        description="An integer describing how many entities exist in the collection before\nthose included in this list. If there was no **skipCount** parameter then the\ndefault value is 0.\n",
    )
    totalItems: Optional[int] = Field(
        None,
        description="An integer describing the total number of entities in the collection.\nThe API might not be able to determine this value,\nin which case this property will not be present.\n",
    )


class PasswordResetBody(BaseModel):
    id: str = Field(
        ..., description="the workflow id provided in the reset password email"
    )
    key: str = Field(
        ..., description="the workflow key provided in the reset password email"
    )
    password: str = Field(..., description="the new password")


class PathElement(BaseModel):
    aspectNames: Optional[List[str]] = None
    id: Optional[str] = None
    name: Optional[str] = None
    nodeType: Optional[str] = None


class PathInfo(BaseModel):
    elements: Optional[List[PathElement]] = None
    isComplete: Optional[bool] = None
    name: Optional[str] = None


class AccessStatus(Enum):
    ALLOWED = "ALLOWED"
    DENIED = "DENIED"


class PermissionElement(BaseModel):
    accessStatus: Optional[AccessStatus] = "ALLOWED"
    authorityId: Optional[str] = None
    name: Optional[str] = None


class PermissionsBody(BaseModel):
    isInheritanceEnabled: Optional[bool] = None
    locallySet: Optional[List[PermissionElement]] = None


class PermissionsInfo(BaseModel):
    inherited: Optional[List[PermissionElement]] = None
    isInheritanceEnabled: Optional[bool] = None
    locallySet: Optional[List[PermissionElement]] = None
    settable: Optional[List[str]] = None


class Person(BaseModel):
    aspectNames: Optional[List[str]] = None
    avatarId: Optional[str] = None
    capabilities: Optional[Capabilities] = None
    company: Optional[Company] = None
    description: Optional[str] = None
    displayName: Optional[str] = None
    email: str
    emailNotificationsEnabled: Optional[bool] = True
    enabled: bool
    firstName: str
    googleId: Optional[str] = None
    id: str
    instantMessageId: Optional[str] = None
    jobTitle: Optional[str] = None
    lastName: Optional[str] = None
    location: Optional[str] = None
    mobile: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    skypeId: Optional[str] = None
    statusUpdatedAt: Optional[datetime] = None
    telephone: Optional[str] = None
    userStatus: Optional[str] = None


class PersonBodyCreate(BaseModel):
    aspectNames: Optional[List[str]] = None
    company: Optional[Company] = None
    description: Optional[str] = None
    email: str
    emailNotificationsEnabled: Optional[bool] = True
    enabled: Optional[bool] = True
    firstName: str
    googleId: Optional[str] = None
    id: str
    instantMessageId: Optional[str] = None
    jobTitle: Optional[str] = None
    lastName: Optional[str] = None
    location: Optional[str] = None
    mobile: Optional[str] = None
    password: str
    properties: Optional[Dict[str, Any]] = None
    skypeId: Optional[str] = None
    telephone: Optional[str] = None
    userStatus: Optional[str] = None


class PersonBodyUpdate(BaseModel):
    aspectNames: Optional[List[str]] = None
    company: Optional[Company] = None
    description: Optional[str] = None
    email: Optional[str] = None
    emailNotificationsEnabled: Optional[bool] = None
    enabled: Optional[bool] = None
    firstName: Optional[str] = None
    googleId: Optional[str] = None
    instantMessageId: Optional[str] = None
    jobTitle: Optional[str] = None
    lastName: Optional[str] = None
    location: Optional[str] = None
    mobile: Optional[str] = None
    oldPassword: Optional[str] = None
    password: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    skypeId: Optional[str] = None
    telephone: Optional[str] = None
    userStatus: Optional[str] = None


class PersonEntry(BaseModel):
    entry: Person


class SubscriptionLevel(Enum):
    Free = "Free"
    Standard = "Standard"
    Enterprise = "Enterprise"


class PersonNetwork(BaseModel):
    createdAt: Optional[datetime] = None
    homeNetwork: Optional[bool] = Field(None, description="Is this the home network?")
    id: str = Field(..., description="This network's unique id")
    isEnabled: bool
    paidNetwork: Optional[bool] = None
    quotas: Optional[List[NetworkQuota]] = None
    subscriptionLevel: Optional[SubscriptionLevel] = None


class PersonNetworkEntry(BaseModel):
    entry: PersonNetwork


class List12(BaseModel):
    entries: Optional[List[PersonNetworkEntry]] = None
    pagination: Optional[Pagination] = None


class PersonNetworkPaging(BaseModel):
    list: List12


class List13(BaseModel):
    entries: Optional[List[PersonEntry]] = None
    pagination: Optional[Pagination] = None


class PersonPaging(BaseModel):
    list: Optional[List13] = None


class Preference(BaseModel):
    id: str = Field(..., description="The unique id of the preference")
    value: Optional[str] = Field(
        None,
        description="The value of the preference. Note that this can be of any JSON type.",
    )


class PreferenceEntry(BaseModel):
    entry: Preference


class List14(BaseModel):
    entries: Optional[List[PreferenceEntry]] = None
    pagination: Optional[Pagination] = None


class PreferencePaging(BaseModel):
    list: List14


class Entry(BaseModel):
    message: Optional[str] = None


class ProbeEntry(BaseModel):
    entry: Entry


class Property(BaseModel):
    constraints: Optional[List[Constraint]] = Field(
        None, description="list of constraints defined for the property"
    )
    dataType: Optional[str] = Field(
        None, description="the name of the property type (e.g. d:text)"
    )
    defaultValue: Optional[str] = Field(None, description="the default value")
    description: Optional[str] = Field(
        None, description="the human-readable description"
    )
    id: str
    isMandatory: Optional[bool] = Field(
        None, description="define if the property is mandatory"
    )
    isMandatoryEnforced: Optional[bool] = Field(
        None, description="define if the presence of mandatory properties is enforced"
    )
    isMultiValued: Optional[bool] = Field(
        None, description="define if the property is multi-valued"
    )
    isProtected: Optional[bool] = Field(
        None, description="define if the property is system maintained"
    )
    title: Optional[str] = Field(None, description="the human-readable title")


class Aggregate(BaseModel):
    average: Optional[int] = None
    numberOfRatings: Optional[int] = None


class Rating(BaseModel):
    aggregate: Aggregate
    id: str
    myRating: Optional[str] = Field(
        None,
        description="The rating. The type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar.",
    )
    ratedAt: Optional[datetime] = None


class Id(Enum):
    likes = "likes"
    fiveStar = "fiveStar"


class RatingBody(BaseModel):
    id: Id = Field(
        ...,
        description="The rating scheme type. Possible values are likes and fiveStar.",
    )
    myRating: str = Field(
        ...,
        description="The rating. The type is specific to the rating scheme, boolean for the likes and an integer for the fiveStar",
    )


class RatingEntry(BaseModel):
    entry: Rating


class List15(BaseModel):
    entries: Optional[List[RatingEntry]] = None
    pagination: Optional[Pagination] = None


class RatingPaging(BaseModel):
    list: List15


class Status1(Enum):
    CREATED = "CREATED"
    NOT_CREATED = "NOT_CREATED"


class Rendition(BaseModel):
    content: Optional[ContentInfo] = None
    id: Optional[str] = None
    status: Optional[Status1] = None


class RenditionBodyCreate(BaseModel):
    id: str


class RenditionEntry(BaseModel):
    entry: Rendition


class List16(BaseModel):
    entries: Optional[List[RenditionEntry]] = None
    pagination: Optional[Pagination] = None


class RenditionPaging(BaseModel):
    list: Optional[List16] = None


class RevertBody(BaseModel):
    comment: Optional[str] = None
    majorVersion: Optional[bool] = None


class SharedLinkBodyCreate(BaseModel):
    expiresAt: Optional[datetime] = None
    nodeId: str


class SharedLinkBodyEmail(BaseModel):
    client: Optional[str] = None
    locale: Optional[str] = None
    message: Optional[str] = None
    recipientEmails: Optional[List[str]] = None


class Role(Enum):
    SiteConsumer = "SiteConsumer"
    SiteCollaborator = "SiteCollaborator"
    SiteContributor = "SiteContributor"
    SiteManager = "SiteManager"


class Visibility(Enum):
    PRIVATE = "PRIVATE"
    MODERATED = "MODERATED"
    PUBLIC = "PUBLIC"


class Site(BaseModel):
    description: Optional[str] = None
    guid: str
    id: str
    preset: Optional[str] = None
    role: Optional[Role] = None
    title: str
    visibility: Visibility


class Visibility1(Enum):
    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"
    MODERATED = "MODERATED"


class SiteBodyCreate(BaseModel):
    description: Optional[str] = None
    id: Optional[str] = None
    title: str
    visibility: Visibility1


class Visibility2(Enum):
    PRIVATE = "PRIVATE"
    MODERATED = "MODERATED"
    PUBLIC = "PUBLIC"


class SiteBodyUpdate(BaseModel):
    description: Optional[str] = None
    title: Optional[str] = None
    visibility: Optional[Visibility2] = None


class SiteContainer(BaseModel):
    folderId: str
    id: str


class SiteContainerEntry(BaseModel):
    entry: SiteContainer


class List18(BaseModel):
    entries: Optional[List[SiteContainerEntry]] = None
    pagination: Optional[Pagination] = None


class SiteContainerPaging(BaseModel):
    list: List18


class SiteEntry(BaseModel):
    entry: Site


class SiteGroup(BaseModel):
    group: GroupMember
    id: str
    role: Role


class SiteGroupEntry(BaseModel):
    entry: SiteGroup


class List19(BaseModel):
    entries: Optional[List[SiteGroupEntry]] = None
    pagination: Optional[Pagination] = None


class SiteGroupPaging(BaseModel):
    list: List19


class SiteMember(BaseModel):
    id: str
    isMemberOfGroup: Optional[bool] = None
    person: Person
    role: Role


class SiteMemberEntry(BaseModel):
    entry: SiteMember


class List20(BaseModel):
    entries: Optional[List[SiteMemberEntry]] = None
    pagination: Optional[Pagination] = None


class SiteMemberPaging(BaseModel):
    list: List20


class SiteMembershipApprovalBody(BaseModel):
    role: Optional[str] = None


class SiteMembershipBodyCreate(BaseModel):
    id: str
    role: Role


class SiteMembershipBodyUpdate(BaseModel):
    role: Role


class SiteMembershipRejectionBody(BaseModel):
    comment: Optional[str] = None


class SiteMembershipRequest(BaseModel):
    createdAt: datetime
    id: str
    message: Optional[str] = None
    site: Site


class SiteMembershipRequestBodyCreate(BaseModel):
    client: Optional[str] = Field(
        None,
        description='Optional client name used when sending an email to the end user, defaults to "share" if not provided.\n**Note:** The client must be registered before this API can send an email.\n**Note:** This is available in Alfresco 7.0.0 and newer versions.\n',
    )
    id: str
    message: Optional[str] = None
    title: Optional[str] = None


class SiteMembershipRequestBodyUpdate(BaseModel):
    message: Optional[str] = None


class SiteMembershipRequestEntry(BaseModel):
    entry: SiteMembershipRequest


class List21(BaseModel):
    entries: Optional[List[SiteMembershipRequestEntry]] = None
    pagination: Optional[Pagination] = None


class SiteMembershipRequestPaging(BaseModel):
    list: List21


class SiteMembershipRequestWithPerson(BaseModel):
    createdAt: datetime
    id: str
    message: Optional[str] = None
    person: Person
    site: Site


class SiteMembershipRequestWithPersonEntry(BaseModel):
    entry: SiteMembershipRequestWithPerson


class List22(BaseModel):
    entries: Optional[List[SiteMembershipRequestWithPersonEntry]] = None
    pagination: Optional[Pagination] = None


class SiteMembershipRequestWithPersonPaging(BaseModel):
    list: List22


class List23(BaseModel):
    entries: Optional[List[SiteEntry]] = None
    pagination: Optional[Pagination] = None


class SitePaging(BaseModel):
    list: List23


class SiteRole(BaseModel):
    guid: str
    id: str
    role: Role
    site: Site


class SiteRoleEntry(BaseModel):
    entry: SiteRole


class List24(BaseModel):
    entries: Optional[List[SiteRoleEntry]] = None
    pagination: Optional[Pagination] = None


class SiteRolePaging(BaseModel):
    list: List24


class Tag(BaseModel):
    count: Optional[float] = None
    id: str
    tag: str


class TagBody(BaseModel):
    tag: str


class TagEntry(BaseModel):
    entry: Tag


class List25(BaseModel):
    entries: Optional[List[TagEntry]] = None
    pagination: Optional[Pagination] = None


class TagPaging(BaseModel):
    list: List25


class UserInfo(BaseModel):
    displayName: str
    id: str


class Version(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    aspectNames: Optional[List[str]] = None
    content: Optional[ContentInfo] = None
    id: str
    isFile: bool
    isFolder: bool
    modifiedAt: datetime
    modifiedByUser: UserInfo
    name: str = Field(
        ...,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    nodeType: str
    properties: Optional[Dict[str, Any]] = None
    versionComment: Optional[str] = None


class VersionEntry(BaseModel):
    entry: Optional[Version] = None


class List26(BaseModel):
    entries: Optional[List[VersionEntry]] = None
    pagination: Optional[Pagination] = None


class VersionPaging(BaseModel):
    list: Optional[List26] = None


class ActionDefinition(BaseModel):
    applicableTypes: List[str] = Field(
        ..., description="QNames of the types this action applies to"
    )
    description: Optional[str] = Field(
        None,
        description='describes the action definition, e.g. "This will move the matched item to another space."',
    )
    id: str = Field(
        ...,
        description="Identifier of the action definition — used for example when executing an action",
    )
    name: Optional[str] = Field(
        None, description='name of the action definition, e.g. "move"'
    )
    parameterDefinitions: Optional[List[ActionParameterDefinition]] = None
    title: Optional[str] = Field(
        None, description='title of the action definition, e.g. "Move"'
    )
    trackStatus: bool = Field(
        ...,
        description="whether the basic action definition supports action tracking or not",
    )


class ActionDefinitionEntry(BaseModel):
    entry: ActionDefinition


class ListModel(BaseModel):
    entries: Optional[List[ActionDefinition]] = None
    pagination: Optional[Pagination] = None


class ActionDefinitionList(BaseModel):
    list: Optional[ListModel] = None


class List1(BaseModel):
    entries: Optional[List[ActivityEntry]] = None
    pagination: Optional[Pagination] = None


class ActivityPaging(BaseModel):
    list: List1


class List2(BaseModel):
    entries: Optional[List[AuditAppEntry]] = None
    pagination: Optional[Pagination] = None


class AuditAppPaging(BaseModel):
    list: Optional[List2] = None


class AuditEntry(BaseModel):
    auditApplicationId: str
    createdAt: datetime
    createdByUser: UserInfo
    id: str
    values: Optional[Dict[str, Any]] = None


class AuditEntryEntry(BaseModel):
    entry: Optional[AuditEntry] = None


class List3(BaseModel):
    entries: Optional[List[AuditEntryEntry]] = None
    pagination: Optional[Pagination] = None


class AuditEntryPaging(BaseModel):
    list: Optional[List3] = None


class Comment(BaseModel):
    canDelete: bool
    canEdit: bool
    content: str
    createdAt: datetime
    createdBy: Person
    edited: bool
    id: str
    modifiedAt: datetime
    modifiedBy: Person
    title: str


class CommentEntry(BaseModel):
    entry: Comment


class List4(BaseModel):
    entries: Optional[List[CommentEntry]] = None
    pagination: Optional[Pagination] = None


class CommentPaging(BaseModel):
    list: List4


class Definition(BaseModel):
    properties: Optional[List[Property]] = Field(
        None,
        description="List of property definitions effective for this node as the result of combining the type with all aspects.",
    )


class List6(BaseModel):
    entries: Optional[List[FavoriteEntry]] = None
    pagination: Optional[Pagination] = None


class FavoritePaging(BaseModel):
    list: List6


class List7(BaseModel):
    entries: Optional[List[GroupMemberEntry]] = None
    pagination: Optional[Pagination] = None


class GroupMemberPaging(BaseModel):
    list: Optional[List7] = None


class List8(BaseModel):
    entries: Optional[List[GroupEntry]] = None
    pagination: Optional[Pagination] = None


class GroupPaging(BaseModel):
    list: Optional[List8] = None


class Node(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    allowableOperations: Optional[List[str]] = None
    aspectNames: Optional[List[str]] = None
    content: Optional[ContentInfo] = None
    createdAt: datetime
    createdByUser: UserInfo
    definition: Optional[Definition] = None
    id: str
    isFavorite: Optional[bool] = None
    isFile: bool
    isFolder: bool
    isLink: Optional[bool] = None
    isLocked: Optional[bool] = False
    modifiedAt: datetime
    modifiedByUser: UserInfo
    name: str = Field(
        ...,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    nodeType: str
    parentId: Optional[str] = None
    path: Optional[PathInfo] = None
    permissions: Optional[PermissionsInfo] = None
    properties: Optional[Dict[str, Any]] = None


class NodeAssociation(Node):
    association: Optional[AssociationInfo] = None


class NodeAssociationEntry(BaseModel):
    entry: NodeAssociation


class List9(BaseModel):
    entries: Optional[List[NodeAssociationEntry]] = None
    pagination: Optional[Pagination] = None
    source: Optional[Node] = None


class NodeAssociationPaging(BaseModel):
    list: Optional[List9] = None


class NodeBodyCreate(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    aspectNames: Optional[List[str]] = None
    association: Optional[Association1] = None
    definition: Optional[Definition] = None
    name: str = Field(
        ...,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    nodeType: str
    permissions: Optional[PermissionsBody] = None
    properties: Optional[Dict[str, Any]] = None
    relativePath: Optional[str] = None
    secondaryChildren: Optional[List[ChildAssociationBody]] = None
    targets: Optional[List[AssociationBody]] = None


class NodeBodyUpdate(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    aspectNames: Optional[List[str]] = None
    name: Optional[str] = Field(
        None,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    nodeType: Optional[str] = None
    permissions: Optional[PermissionsBody] = None
    properties: Optional[Dict[str, str]] = None


class NodeChildAssociation(Node):
    association: Optional[ChildAssociationInfo] = None


class NodeChildAssociationEntry(BaseModel):
    entry: NodeChildAssociation


class List10(BaseModel):
    entries: Optional[List[NodeChildAssociationEntry]] = None
    pagination: Optional[Pagination] = None
    source: Optional[Node] = None


class NodeChildAssociationPaging(BaseModel):
    list: Optional[List10] = None


class NodeEntry(BaseModel):
    entry: Node


class List11(BaseModel):
    entries: Optional[List[NodeEntry]] = None
    pagination: Optional[Pagination] = None
    source: Optional[Node] = None


class NodePaging(BaseModel):
    list: Optional[List11] = None


class SharedLink(BaseModel):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    allowableOperations: Optional[List[str]] = Field(
        None,
        description="The allowable operations for the Quickshare link itself. See allowableOperationsOnTarget for the\nallowable operations pertaining to the linked content node.\n",
    )
    allowableOperationsOnTarget: Optional[List[str]] = Field(
        None,
        description="The allowable operations for the content node being shared.\n",
    )
    aspectNames: Optional[List[str]] = None
    content: Optional[ContentInfo] = None
    description: Optional[str] = None
    expiresAt: Optional[datetime] = None
    id: Optional[str] = None
    isFavorite: Optional[bool] = None
    modifiedAt: Optional[datetime] = None
    modifiedByUser: Optional[UserInfo] = None
    name: Optional[str] = Field(
        None,
        description='The name must not contain spaces or the following special characters: * " < > \\ / ? : and |.\nThe character . must not be used at the end of the name.\n',
        pattern='^(?!(.*[\\"\\*\\\\\\>\\<\\?\\/\\:\\|]+.*)|(.*[\\.]?.*[\\.]+$)|(.*[ ]+$))',
    )
    nodeId: Optional[str] = None
    path: Optional[PathInfo] = None
    properties: Optional[Dict[str, Any]] = Field(
        None,
        description="A subset of the target node's properties, system properties and properties already available in the SharedLink are excluded.\n",
    )
    sharedByUser: Optional[UserInfo] = None
    title: Optional[str] = None


class SharedLinkEntry(BaseModel):
    entry: SharedLink


class List17(BaseModel):
    entries: Optional[List[SharedLinkEntry]] = None
    pagination: Optional[Pagination] = None


class SharedLinkPaging(BaseModel):
    list: List17


class DeletedNode(Node):
    archivedAt: datetime
    archivedByUser: UserInfo


class DeletedNodeEntry(BaseModel):
    entry: Optional[DeletedNode] = None


class List5(BaseModel):
    entries: Optional[List[DeletedNodeEntry]] = None
    pagination: Optional[Pagination] = None


class DeletedNodesPaging(BaseModel):
    list: Optional[List5] = None
