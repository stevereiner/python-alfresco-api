# coding: utf-8

"""
    Alfresco Content Services REST API

    **Workflow API**  Provides access to the workflow features of Alfresco Content Services. 

    The version of the OpenAPI document: 1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from alfresco_workflow_client.models.candidate_paging import CandidatePaging
from alfresco_workflow_client.models.item_body import ItemBody
from alfresco_workflow_client.models.item_paging import ItemPaging
from alfresco_workflow_client.models.task_body import TaskBody
from alfresco_workflow_client.models.task_entry import TaskEntry
from alfresco_workflow_client.models.task_form_model_paging import TaskFormModelPaging
from alfresco_workflow_client.models.task_paging import TaskPaging
from alfresco_workflow_client.models.variable import Variable
from alfresco_workflow_client.models.variable_entry import VariableEntry
from alfresco_workflow_client.models.variable_paging import VariablePaging

from alfresco_workflow_client.api_client import ApiClient, RequestSerialized
from alfresco_workflow_client.api_response import ApiResponse
from alfresco_workflow_client.rest import RESTResponseType


class TasksApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_task_item(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        item_body: Annotated[ItemBody, Field(description="The nodeId of the item")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ItemPaging:
        """Create an item

        Creates an item for a given task **taskId**.  If the item  already is part of that task the request will have no effect.  **Note:** You can create more than one item by specifying a list of items in the JSON body like this:  ```JSON [   {      \"id\": \"1ff9da1a-ee2f-4b9c-8c34-44665e844444\"   },   {      \"id\": \"1ff9da1a-ee2f-4b9c-8c34-44665e855555\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {           ...         }       }     ]   } } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param item_body: The nodeId of the item (required)
        :type item_body: ItemBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_item_serialize(
            task_id=task_id,
            item_body=item_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ItemPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_task_item_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        item_body: Annotated[ItemBody, Field(description="The nodeId of the item")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ItemPaging]:
        """Create an item

        Creates an item for a given task **taskId**.  If the item  already is part of that task the request will have no effect.  **Note:** You can create more than one item by specifying a list of items in the JSON body like this:  ```JSON [   {      \"id\": \"1ff9da1a-ee2f-4b9c-8c34-44665e844444\"   },   {      \"id\": \"1ff9da1a-ee2f-4b9c-8c34-44665e855555\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {           ...         }       }     ]   } } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param item_body: The nodeId of the item (required)
        :type item_body: ItemBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_item_serialize(
            task_id=task_id,
            item_body=item_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ItemPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_task_item_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        item_body: Annotated[ItemBody, Field(description="The nodeId of the item")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an item

        Creates an item for a given task **taskId**.  If the item  already is part of that task the request will have no effect.  **Note:** You can create more than one item by specifying a list of items in the JSON body like this:  ```JSON [   {      \"id\": \"1ff9da1a-ee2f-4b9c-8c34-44665e844444\"   },   {      \"id\": \"1ff9da1a-ee2f-4b9c-8c34-44665e855555\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {           ...         }       }     ]   } } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param item_body: The nodeId of the item (required)
        :type item_body: ItemBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_item_serialize(
            task_id=task_id,
            item_body=item_body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ItemPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_task_item_serialize(
        self,
        task_id,
        item_body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if item_body is not None:
            _body_params = item_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tasks/{taskId}/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_task_variables(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable: Annotated[Variable, Field(description="A variable")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VariableEntry:
        """Create or update variables

        Create or update a variable for the task **taskId**. If the variable does not exist yet, it will be created.         **Note:** You can create or update more than one variable by  specifying a list of variables in the JSON body like this:  ```JSON [   {     \"name\": \"string\",     \"value\": \"string\",     \"type\": \"string\"   },   {     \"name\": \"string\",     \"value\": \"string\",     \"type\": \"string\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {          ...         }       }     ]   } } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable: A variable (required)
        :type variable: Variable
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_variables_serialize(
            task_id=task_id,
            variable=variable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VariableEntry",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_task_variables_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable: Annotated[Variable, Field(description="A variable")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VariableEntry]:
        """Create or update variables

        Create or update a variable for the task **taskId**. If the variable does not exist yet, it will be created.         **Note:** You can create or update more than one variable by  specifying a list of variables in the JSON body like this:  ```JSON [   {     \"name\": \"string\",     \"value\": \"string\",     \"type\": \"string\"   },   {     \"name\": \"string\",     \"value\": \"string\",     \"type\": \"string\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {          ...         }       }     ]   } } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable: A variable (required)
        :type variable: Variable
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_variables_serialize(
            task_id=task_id,
            variable=variable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VariableEntry",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_task_variables_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable: Annotated[Variable, Field(description="A variable")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update variables

        Create or update a variable for the task **taskId**. If the variable does not exist yet, it will be created.         **Note:** You can create or update more than one variable by  specifying a list of variables in the JSON body like this:  ```JSON [   {     \"name\": \"string\",     \"value\": \"string\",     \"type\": \"string\"   },   {     \"name\": \"string\",     \"value\": \"string\",     \"type\": \"string\"   } ] ``` If you specify a list as input, then a paginated list rather than an entry is returned in the response body. For example:  ```JSON {   \"list\": {     \"pagination\": {       \"count\": 2,       \"hasMoreItems\": false,       \"totalItems\": 2,       \"skipCount\": 0,       \"maxItems\": 100     },     \"entries\": [       {         \"entry\": {           ...         }       },       {         \"entry\": {          ...         }       }     ]   } } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable: A variable (required)
        :type variable: Variable
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_task_variables_serialize(
            task_id=task_id,
            variable=variable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "VariableEntry",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_task_variables_serialize(
        self,
        task_id,
        variable,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if variable is not None:
            _body_params = variable


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tasks/{taskId}/variables',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_task_item(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        item_id: Annotated[StrictStr, Field(description="The identifier of an item.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete an item

        Deletes the item with the specified **itemId** from the task with the specified **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param item_id: The identifier of an item. (required)
        :type item_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_item_serialize(
            task_id=task_id,
            item_id=item_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_task_item_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        item_id: Annotated[StrictStr, Field(description="The identifier of an item.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete an item

        Deletes the item with the specified **itemId** from the task with the specified **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param item_id: The identifier of an item. (required)
        :type item_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_item_serialize(
            task_id=task_id,
            item_id=item_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_task_item_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        item_id: Annotated[StrictStr, Field(description="The identifier of an item.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an item

        Deletes the item with the specified **itemId** from the task with the specified **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param item_id: The identifier of an item. (required)
        :type item_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_item_serialize(
            task_id=task_id,
            item_id=item_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_task_item_serialize(
        self,
        task_id,
        item_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        if item_id is not None:
            _path_params['itemId'] = item_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/tasks/{taskId}/items/{itemId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_task_variable(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable_name: Annotated[StrictStr, Field(description="The name of a variable.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a variable

        Deletes the variable with the specified **variableName** from the task with the specified **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable_name: The name of a variable. (required)
        :type variable_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_variable_serialize(
            task_id=task_id,
            variable_name=variable_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_task_variable_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable_name: Annotated[StrictStr, Field(description="The name of a variable.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a variable

        Deletes the variable with the specified **variableName** from the task with the specified **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable_name: The name of a variable. (required)
        :type variable_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_variable_serialize(
            task_id=task_id,
            variable_name=variable_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_task_variable_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable_name: Annotated[StrictStr, Field(description="The name of a variable.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a variable

        Deletes the variable with the specified **variableName** from the task with the specified **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable_name: The name of a variable. (required)
        :type variable_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_task_variable_serialize(
            task_id=task_id,
            variable_name=variable_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_task_variable_serialize(
        self,
        task_id,
        variable_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        if variable_name is not None:
            _path_params['variableName'] = variable_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/tasks/{taskId}/variables/{variableName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TaskEntry:
        """Get a task

        Gets the task identified by **taskId**.  An authenticated user will have access to a task if the user has started the process or if the user is involved in any of the process’s tasks. In a network, only tasks that are inside the given network are returned.  In non-network deployments, administrators can see all processes and perform all operations on tasks. In network deployments, network administrators can see all processes in their network and perform all operations on tasks in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_task_serialize(
            task_id=task_id,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskEntry",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TaskEntry]:
        """Get a task

        Gets the task identified by **taskId**.  An authenticated user will have access to a task if the user has started the process or if the user is involved in any of the process’s tasks. In a network, only tasks that are inside the given network are returned.  In non-network deployments, administrators can see all processes and perform all operations on tasks. In network deployments, network administrators can see all processes in their network and perform all operations on tasks in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_task_serialize(
            task_id=task_id,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskEntry",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_task_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a task

        Gets the task identified by **taskId**.  An authenticated user will have access to a task if the user has started the process or if the user is involved in any of the process’s tasks. In a network, only tasks that are inside the given network are returned.  In non-network deployments, administrators can see all processes and perform all operations on tasks. In network deployments, network administrators can see all processes in their network and perform all operations on tasks in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_task_serialize(
            task_id=task_id,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskEntry",
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_task_serialize(
        self,
        task_id,
        properties,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tasks/{taskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_task_form_model(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TaskFormModelPaging:
        """Get a task form model

        Gets the model of the task form type definition.  An authenticated user will have access to  access to all task form models. In a network, only task form models that are inside the given network are returned. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_task_form_model_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskFormModelPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_task_form_model_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TaskFormModelPaging]:
        """Get a task form model

        Gets the model of the task form type definition.  An authenticated user will have access to  access to all task form models. In a network, only task form models that are inside the given network are returned. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_task_form_model_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskFormModelPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_task_form_model_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a task form model

        Gets the model of the task form type definition.  An authenticated user will have access to  access to all task form models. In a network, only task form models that are inside the given network are returned. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_task_form_model_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskFormModelPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_task_form_model_serialize(
        self,
        task_id,
        skip_count,
        max_items,
        properties,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        if skip_count is not None:
            
            _query_params.append(('skipCount', skip_count))
            
        if max_items is not None:
            
            _query_params.append(('maxItems', max_items))
            
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tasks/{taskId}/task-form-model',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_candidates(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CandidatePaging:
        """List task candidates

        Gets a list of candidate users and groups for the specified task **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_candidates_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CandidatePaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_candidates_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CandidatePaging]:
        """List task candidates

        Gets a list of candidate users and groups for the specified task **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_candidates_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CandidatePaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_candidates_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List task candidates

        Gets a list of candidate users and groups for the specified task **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_candidates_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CandidatePaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_candidates_serialize(
        self,
        task_id,
        skip_count,
        max_items,
        properties,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        if skip_count is not None:
            
            _query_params.append(('skipCount', skip_count))
            
        if max_items is not None:
            
            _query_params.append(('maxItems', max_items))
            
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tasks/{taskId}/candidates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_items(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ItemPaging:
        """List items

        Gets a list of items for the specified task **taskId**.  An authenticated user will have access to a task's items if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only items for a process that is inside the given network are returned.  In non-network deployments, administrators can see all items and perform all operations  on those items. In network deployments, network administrators can see all items in their network and perform all operations on items in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_items_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ItemPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_items_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ItemPaging]:
        """List items

        Gets a list of items for the specified task **taskId**.  An authenticated user will have access to a task's items if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only items for a process that is inside the given network are returned.  In non-network deployments, administrators can see all items and perform all operations  on those items. In network deployments, network administrators can see all items in their network and perform all operations on items in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_items_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ItemPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_items_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List items

        Gets a list of items for the specified task **taskId**.  An authenticated user will have access to a task's items if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only items for a process that is inside the given network are returned.  In non-network deployments, administrators can see all items and perform all operations  on those items. In network deployments, network administrators can see all items in their network and perform all operations on items in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_items_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ItemPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_items_serialize(
        self,
        task_id,
        skip_count,
        max_items,
        properties,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        if skip_count is not None:
            
            _query_params.append(('skipCount', skip_count))
            
        if max_items is not None:
            
            _query_params.append(('maxItems', max_items))
            
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tasks/{taskId}/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_task_variables(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        where: Annotated[Optional[StrictStr], Field(description="A string to restrict the returned objects by using a predicate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VariablePaging:
        """List variables

        Gets a list of variables for the specified task **taskId**.  An authenticated user will have access to a tasks variables if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only variables for a process that is inside the given network are returned.  In non-network deployments, administrators can see all variables and perform all operations  on those variable. In network deployments, network administrators can see all variables in  their network and perform all operations on variables in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param where: A string to restrict the returned objects by using a predicate.
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_variables_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VariablePaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_task_variables_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        where: Annotated[Optional[StrictStr], Field(description="A string to restrict the returned objects by using a predicate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VariablePaging]:
        """List variables

        Gets a list of variables for the specified task **taskId**.  An authenticated user will have access to a tasks variables if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only variables for a process that is inside the given network are returned.  In non-network deployments, administrators can see all variables and perform all operations  on those variable. In network deployments, network administrators can see all variables in  their network and perform all operations on variables in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param where: A string to restrict the returned objects by using a predicate.
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_variables_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VariablePaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_task_variables_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        where: Annotated[Optional[StrictStr], Field(description="A string to restrict the returned objects by using a predicate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List variables

        Gets a list of variables for the specified task **taskId**.  An authenticated user will have access to a tasks variables if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only variables for a process that is inside the given network are returned.  In non-network deployments, administrators can see all variables and perform all operations  on those variable. In network deployments, network administrators can see all variables in  their network and perform all operations on variables in their network. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param where: A string to restrict the returned objects by using a predicate.
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_task_variables_serialize(
            task_id=task_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VariablePaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_task_variables_serialize(
        self,
        task_id,
        skip_count,
        max_items,
        properties,
        where,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        if skip_count is not None:
            
            _query_params.append(('skipCount', skip_count))
            
        if max_items is not None:
            
            _query_params.append(('maxItems', max_items))
            
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        if where is not None:
            
            _query_params.append(('where', where))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tasks/{taskId}/variables',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_tasks(
        self,
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. ")] = None,
        where: Annotated[Optional[StrictStr], Field(description="A string to restrict the returned objects by using a predicate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TaskPaging:
        """List tasks

        Gets a list of tasks visible to the authenticated user.  Tasks are returned for which the authenticated user is the assignee  or a candidate. If networks are enabled, the only tasks that are inside the given network are returned.  In non-network deployments, administrators can see all processes and perform all operations on tasks. In network deployments, network administrators can see all processes in their network and perform all operations on tasks in their network. 

        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param order_by: A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
        :type order_by: List[str]
        :param where: A string to restrict the returned objects by using a predicate.
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tasks_serialize(
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            order_by=order_by,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskPaging",
            '400': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_tasks_with_http_info(
        self,
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. ")] = None,
        where: Annotated[Optional[StrictStr], Field(description="A string to restrict the returned objects by using a predicate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TaskPaging]:
        """List tasks

        Gets a list of tasks visible to the authenticated user.  Tasks are returned for which the authenticated user is the assignee  or a candidate. If networks are enabled, the only tasks that are inside the given network are returned.  In non-network deployments, administrators can see all processes and perform all operations on tasks. In network deployments, network administrators can see all processes in their network and perform all operations on tasks in their network. 

        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param order_by: A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
        :type order_by: List[str]
        :param where: A string to restrict the returned objects by using a predicate.
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tasks_serialize(
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            order_by=order_by,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskPaging",
            '400': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_tasks_without_preload_content(
        self,
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. ")] = None,
        where: Annotated[Optional[StrictStr], Field(description="A string to restrict the returned objects by using a predicate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List tasks

        Gets a list of tasks visible to the authenticated user.  Tasks are returned for which the authenticated user is the assignee  or a candidate. If networks are enabled, the only tasks that are inside the given network are returned.  In non-network deployments, administrators can see all processes and perform all operations on tasks. In network deployments, network administrators can see all processes in their network and perform all operations on tasks in their network. 

        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param order_by: A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
        :type order_by: List[str]
        :param where: A string to restrict the returned objects by using a predicate.
        :type where: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tasks_serialize(
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            order_by=order_by,
            where=where,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskPaging",
            '400': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_tasks_serialize(
        self,
        skip_count,
        max_items,
        properties,
        order_by,
        where,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
            'orderBy': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if skip_count is not None:
            
            _query_params.append(('skipCount', skip_count))
            
        if max_items is not None:
            
            _query_params.append(('maxItems', max_items))
            
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        if where is not None:
            
            _query_params.append(('where', where))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tasks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_tasks_for_process(
        self,
        process_id: Annotated[StrictStr, Field(description="The identifier of a process.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TaskPaging:
        """List tasks for a process

        Gets a list of tasks for the specified process **processId**.  An authenticated user will have access to a processes tasks if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only tasks for a process that is inside the given network are returned.  In non-network deployments, administrators can see all tasks and perform all operations  on those tasks. In network deployments, network administrators can see all tasks in their network and perform all operations on tasks in their network. 

        :param process_id: The identifier of a process. (required)
        :type process_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param order_by: A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
        :type order_by: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tasks_for_process_serialize(
            process_id=process_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_tasks_for_process_with_http_info(
        self,
        process_id: Annotated[StrictStr, Field(description="The identifier of a process.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TaskPaging]:
        """List tasks for a process

        Gets a list of tasks for the specified process **processId**.  An authenticated user will have access to a processes tasks if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only tasks for a process that is inside the given network are returned.  In non-network deployments, administrators can see all tasks and perform all operations  on those tasks. In network deployments, network administrators can see all tasks in their network and perform all operations on tasks in their network. 

        :param process_id: The identifier of a process. (required)
        :type process_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param order_by: A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
        :type order_by: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tasks_for_process_serialize(
            process_id=process_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_tasks_for_process_without_preload_content(
        self,
        process_id: Annotated[StrictStr, Field(description="The identifier of a process.")],
        skip_count: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of entities that  exist in the collection before those included in this list.")] = None,
        max_items: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of items to return in the list.")] = None,
        properties: Annotated[Optional[List[StrictStr]], Field(description="A list of property names. You can use the properties parameter to restrict the number of returned properties.")] = None,
        order_by: Annotated[Optional[List[StrictStr]], Field(description="A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List tasks for a process

        Gets a list of tasks for the specified process **processId**.  An authenticated user will have access to a processes tasks if the user has started the process or if the user is involved in any of the process’s tasks.  In a network, only tasks for a process that is inside the given network are returned.  In non-network deployments, administrators can see all tasks and perform all operations  on those tasks. In network deployments, network administrators can see all tasks in their network and perform all operations on tasks in their network. 

        :param process_id: The identifier of a process. (required)
        :type process_id: str
        :param skip_count: The number of entities that  exist in the collection before those included in this list.
        :type skip_count: int
        :param max_items: The maximum number of items to return in the list.
        :type max_items: int
        :param properties: A list of property names. You can use the properties parameter to restrict the number of returned properties.
        :type properties: List[str]
        :param order_by: A string to control the order of the entities returned in a list. You can use the **orderby** parameter to sort the list by one or more fields.  Each field has a default sort order, which is normally ascending order. Read the API method implementation notes above to check if any fields used in this method have a descending default search order.  To sort the entities in a specific order, you can use the **ASC** and **DESC** keywords for any field. 
        :type order_by: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_tasks_for_process_serialize(
            process_id=process_id,
            skip_count=skip_count,
            max_items=max_items,
            properties=properties,
            order_by=order_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskPaging",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_tasks_for_process_serialize(
        self,
        process_id,
        skip_count,
        max_items,
        properties,
        order_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'properties': 'csv',
            'orderBy': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if process_id is not None:
            _path_params['processId'] = process_id
        # process the query parameters
        if skip_count is not None:
            
            _query_params.append(('skipCount', skip_count))
            
        if max_items is not None:
            
            _query_params.append(('maxItems', max_items))
            
        if properties is not None:
            
            _query_params.append(('properties', properties))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/processes/{processId}/tasks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        task_body: Annotated[TaskBody, Field(description="An object containing the properties to be updated")],
        select: Annotated[Optional[StrictInt], Field(description="A string specifying a required subset of properties to be returned for an entity or list of entities. Properties are separated by commas.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TaskEntry:
        """Update a task

        Updates the state of the task **taskId**.  To perform a task action the authenticated user must be the assignee  or a candidate. If networks is enabled, the task action is only performed  if the task is inside the given network.  In non-network deployments, administrators can perform all operations on  tasks. In network deployments, network administrators can see all tasks  in their network and perform all operations on tasks in their network.  You use the **select** parameter in the URL to specify a comma-separated list of properties in the task that you want to update. Use the JSON body to specify the new values for those properties.  So for example to change the state of task **123** to **completed**, use this URL http://localhost:8080/alfresco/api/-default-/public/workflow/versions/1/tasks/123?select=state, and provide this request body:  ```JSON {   \"state\": \"completed\" } ``` State Transitions =================  Clients can invoke actions by assigning an allowed value to the state property of a task. The select parameter can be used to allow for a partial update of the resource. Alfresco will check for illegal state transitions and return an HTTP Bad Request (Response 400) if an illegal state transition is attempted. There are five state transitions, completing, claiming, unclaiming, delegating, resolving.  Completing a task -----------------  If variables are included in the JSON body, they will be set in the task and then the process will continue.  To complete a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  In non-network deployments, administrators can perform this task operation on all tasks. In network deployments, network administrators can perform this action on all tasks in their network.  Here's an example PUT request  ``` /tasks/123?select=state,variables ``` Here's is a corresponding PUT request body:  ```JSON {   “state : “completed”,   “variables” : [   {     \"name\" : \"bpm_priority\",     \"type\" : \"d_int\",     \"value\" : 1,     \"scope\" : \"global\"   }  ] } ```  Claiming a task -----------------  To claim a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “claimed” } ```  Unclaiming a task -----------------  This removes the current assignee of the task.  To unclaim a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “unclaimed” } ```  Delegating a task -----------------  This delegates the task from the owner to an assignee. The result is the same as if the assignee had claimed the task, but the task can then be resolved and the owner will become the assignee again.  To delegate a task, the authenticated user must be the assignee of the task and the assignee must be different from the owner.  Here's an example PUT request  ``` /tasks/123?select=state,assignee ``` Here's a corresponding PUT request body:  ```JSON {   “state : “delegated”,   “assignee : “Kermit” } ``` Resolving a task -----------------  This returns a delegated task back to the owner. In order to delegate a task, the authenticated user must be the assignee of the task and the assignee must be different from the owner.  To resolve a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “resolved” } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param task_body: An object containing the properties to be updated (required)
        :type task_body: TaskBody
        :param select: A string specifying a required subset of properties to be returned for an entity or list of entities. Properties are separated by commas.
        :type select: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_serialize(
            task_id=task_id,
            task_body=task_body,
            select=select,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskEntry",
            '400': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        task_body: Annotated[TaskBody, Field(description="An object containing the properties to be updated")],
        select: Annotated[Optional[StrictInt], Field(description="A string specifying a required subset of properties to be returned for an entity or list of entities. Properties are separated by commas.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TaskEntry]:
        """Update a task

        Updates the state of the task **taskId**.  To perform a task action the authenticated user must be the assignee  or a candidate. If networks is enabled, the task action is only performed  if the task is inside the given network.  In non-network deployments, administrators can perform all operations on  tasks. In network deployments, network administrators can see all tasks  in their network and perform all operations on tasks in their network.  You use the **select** parameter in the URL to specify a comma-separated list of properties in the task that you want to update. Use the JSON body to specify the new values for those properties.  So for example to change the state of task **123** to **completed**, use this URL http://localhost:8080/alfresco/api/-default-/public/workflow/versions/1/tasks/123?select=state, and provide this request body:  ```JSON {   \"state\": \"completed\" } ``` State Transitions =================  Clients can invoke actions by assigning an allowed value to the state property of a task. The select parameter can be used to allow for a partial update of the resource. Alfresco will check for illegal state transitions and return an HTTP Bad Request (Response 400) if an illegal state transition is attempted. There are five state transitions, completing, claiming, unclaiming, delegating, resolving.  Completing a task -----------------  If variables are included in the JSON body, they will be set in the task and then the process will continue.  To complete a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  In non-network deployments, administrators can perform this task operation on all tasks. In network deployments, network administrators can perform this action on all tasks in their network.  Here's an example PUT request  ``` /tasks/123?select=state,variables ``` Here's is a corresponding PUT request body:  ```JSON {   “state : “completed”,   “variables” : [   {     \"name\" : \"bpm_priority\",     \"type\" : \"d_int\",     \"value\" : 1,     \"scope\" : \"global\"   }  ] } ```  Claiming a task -----------------  To claim a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “claimed” } ```  Unclaiming a task -----------------  This removes the current assignee of the task.  To unclaim a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “unclaimed” } ```  Delegating a task -----------------  This delegates the task from the owner to an assignee. The result is the same as if the assignee had claimed the task, but the task can then be resolved and the owner will become the assignee again.  To delegate a task, the authenticated user must be the assignee of the task and the assignee must be different from the owner.  Here's an example PUT request  ``` /tasks/123?select=state,assignee ``` Here's a corresponding PUT request body:  ```JSON {   “state : “delegated”,   “assignee : “Kermit” } ``` Resolving a task -----------------  This returns a delegated task back to the owner. In order to delegate a task, the authenticated user must be the assignee of the task and the assignee must be different from the owner.  To resolve a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “resolved” } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param task_body: An object containing the properties to be updated (required)
        :type task_body: TaskBody
        :param select: A string specifying a required subset of properties to be returned for an entity or list of entities. Properties are separated by commas.
        :type select: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_serialize(
            task_id=task_id,
            task_body=task_body,
            select=select,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskEntry",
            '400': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        task_body: Annotated[TaskBody, Field(description="An object containing the properties to be updated")],
        select: Annotated[Optional[StrictInt], Field(description="A string specifying a required subset of properties to be returned for an entity or list of entities. Properties are separated by commas.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a task

        Updates the state of the task **taskId**.  To perform a task action the authenticated user must be the assignee  or a candidate. If networks is enabled, the task action is only performed  if the task is inside the given network.  In non-network deployments, administrators can perform all operations on  tasks. In network deployments, network administrators can see all tasks  in their network and perform all operations on tasks in their network.  You use the **select** parameter in the URL to specify a comma-separated list of properties in the task that you want to update. Use the JSON body to specify the new values for those properties.  So for example to change the state of task **123** to **completed**, use this URL http://localhost:8080/alfresco/api/-default-/public/workflow/versions/1/tasks/123?select=state, and provide this request body:  ```JSON {   \"state\": \"completed\" } ``` State Transitions =================  Clients can invoke actions by assigning an allowed value to the state property of a task. The select parameter can be used to allow for a partial update of the resource. Alfresco will check for illegal state transitions and return an HTTP Bad Request (Response 400) if an illegal state transition is attempted. There are five state transitions, completing, claiming, unclaiming, delegating, resolving.  Completing a task -----------------  If variables are included in the JSON body, they will be set in the task and then the process will continue.  To complete a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  In non-network deployments, administrators can perform this task operation on all tasks. In network deployments, network administrators can perform this action on all tasks in their network.  Here's an example PUT request  ``` /tasks/123?select=state,variables ``` Here's is a corresponding PUT request body:  ```JSON {   “state : “completed”,   “variables” : [   {     \"name\" : \"bpm_priority\",     \"type\" : \"d_int\",     \"value\" : 1,     \"scope\" : \"global\"   }  ] } ```  Claiming a task -----------------  To claim a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “claimed” } ```  Unclaiming a task -----------------  This removes the current assignee of the task.  To unclaim a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “unclaimed” } ```  Delegating a task -----------------  This delegates the task from the owner to an assignee. The result is the same as if the assignee had claimed the task, but the task can then be resolved and the owner will become the assignee again.  To delegate a task, the authenticated user must be the assignee of the task and the assignee must be different from the owner.  Here's an example PUT request  ``` /tasks/123?select=state,assignee ``` Here's a corresponding PUT request body:  ```JSON {   “state : “delegated”,   “assignee : “Kermit” } ``` Resolving a task -----------------  This returns a delegated task back to the owner. In order to delegate a task, the authenticated user must be the assignee of the task and the assignee must be different from the owner.  To resolve a task, the authenticated user must be the assignee of the task, the owner of the task, or have started the process.  Here's an example PUT request  ``` /tasks/123?select=state ``` Here's a corresponding PUT request body:  ```JSON {   “state : “resolved” } ``` 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param task_body: An object containing the properties to be updated (required)
        :type task_body: TaskBody
        :param select: A string specifying a required subset of properties to be returned for an entity or list of entities. Properties are separated by commas.
        :type select: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_serialize(
            task_id=task_id,
            task_body=task_body,
            select=select,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TaskEntry",
            '400': None,
            '401': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_serialize(
        self,
        task_id,
        task_body,
        select,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        # process the query parameters
        if select is not None:
            
            _query_params.append(('select', select))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if task_body is not None:
            _body_params = task_body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/tasks/{taskId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_task_variable(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable_name: Annotated[StrictStr, Field(description="The name of a variable.")],
        variable: Annotated[Variable, Field(description="A variable")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VariableEntry:
        """Create or update a variable

        Creates or updates a specific variable **variableName** for a given task **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable_name: The name of a variable. (required)
        :type variable_name: str
        :param variable: A variable (required)
        :type variable: Variable
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_variable_serialize(
            task_id=task_id,
            variable_name=variable_name,
            variable=variable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VariableEntry",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_task_variable_with_http_info(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable_name: Annotated[StrictStr, Field(description="The name of a variable.")],
        variable: Annotated[Variable, Field(description="A variable")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VariableEntry]:
        """Create or update a variable

        Creates or updates a specific variable **variableName** for a given task **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable_name: The name of a variable. (required)
        :type variable_name: str
        :param variable: A variable (required)
        :type variable: Variable
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_variable_serialize(
            task_id=task_id,
            variable_name=variable_name,
            variable=variable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VariableEntry",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_task_variable_without_preload_content(
        self,
        task_id: Annotated[StrictStr, Field(description="The identifier of a task.")],
        variable_name: Annotated[StrictStr, Field(description="The name of a variable.")],
        variable: Annotated[Variable, Field(description="A variable")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update a variable

        Creates or updates a specific variable **variableName** for a given task **taskId**. 

        :param task_id: The identifier of a task. (required)
        :type task_id: str
        :param variable_name: The name of a variable. (required)
        :type variable_name: str
        :param variable: A variable (required)
        :type variable: Variable
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_task_variable_serialize(
            task_id=task_id,
            variable_name=variable_name,
            variable=variable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VariableEntry",
            '400': None,
            '401': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_task_variable_serialize(
        self,
        task_id,
        variable_name,
        variable,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if task_id is not None:
            _path_params['taskId'] = task_id
        if variable_name is not None:
            _path_params['variableName'] = variable_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if variable is not None:
            _body_params = variable


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/tasks/{taskId}/variables/{variableName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


